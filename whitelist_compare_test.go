package main

import (
	"encoding/json"
	"io"
	"net/http"
	"os"
	"sort"
	"strings"
	"testing"
)

// TestWhitelistMatchesReference compares the whitelist built by Go code
// against a reference list generated by the Python blueprint.
func TestWhitelistMatchesReference(t *testing.T) {
	setupTestDB(t)
	defer db.Close()

	// Load reference whitelist with state and stake data
	var entries []struct {
		Address string  `json:"address"`
		State   string  `json:"state"`
		Stake   float64 `json:"stake,string"`
	}
	data, err := os.ReadFile("data/whitelist_epoch_164.json")
	if err != nil {
		t.Fatalf("read reference: %v", err)
	}
	if err := json.Unmarshal(data, &entries); err != nil {
		t.Fatalf("parse reference: %v", err)
	}

	// Prepare epochIdentity slice for buildEpochWhitelist
	var ids []epochIdentity
	var refAddrs []string
	thr := 1e9
	for _, e := range entries {
		ids = append(ids, epochIdentity{Address: e.Address, State: e.State, Stake: e.Stake})
		refAddrs = append(refAddrs, strings.ToLower(e.Address))
		if e.State == "Human" && e.Stake < thr {
			thr = e.Stake
		}
	}
	if thr == 1e9 {
		thr = 0
	}
	sort.Strings(refAddrs)

	// Stub fetchEpochIdentitiesFn
	oldFetch := fetchEpochIdentitiesFn
	fetchEpochIdentitiesFn = func(epoch int) ([]epochIdentity, error) { return ids, nil }
	defer func() { fetchEpochIdentitiesFn = oldFetch }()

	// Stub network calls for penalties and flip reports
	oldClient := http.DefaultClient
	http.DefaultClient = &http.Client{Transport: roundTripFunc(func(req *http.Request) (*http.Response, error) {
		if req.URL.String() == idenaRpcUrl {
			resp := `{"result":{"lastValidationFlags":[]}}`
			return &http.Response{StatusCode: 200, Body: io.NopCloser(strings.NewReader(resp)), Header: make(http.Header)}, nil
		}
		if strings.Contains(req.URL.Path, "ValidationSummary") {
			resp := `{"result":{"penalized":false}}`
			return &http.Response{StatusCode: 200, Body: io.NopCloser(strings.NewReader(resp)), Header: make(http.Header)}, nil
		}
		return nil, nil
	})}
	defer func() { http.DefaultClient = oldClient }()

	if err := buildEpochWhitelist(164, thr); err != nil {
		t.Fatalf("build whitelist: %v", err)
	}
	list, err := getWhitelist()
	if err != nil {
		t.Fatalf("get whitelist: %v", err)
	}
	for i := range list {
		list[i] = strings.ToLower(list[i])
	}
	sort.Strings(list)

	if len(list) != len(refAddrs) {
		t.Fatalf("list length mismatch: got %d want %d", len(list), len(refAddrs))
	}
	for i := range list {
		if list[i] != refAddrs[i] {
			t.Fatalf("address mismatch at %d: %s vs %s", i, list[i], refAddrs[i])
		}
	}
}
